Part 1 Write-up: Coding Summary
Audrey Link, Aloye Oshotse, and Jason Qiu


Program Design: 
Our program is designed to take in a password input from the command line and use several functions to compare different chunks of it to encrypted versions of the valid password. It is written such that only encrypted or broken up copies of the true password are present in the program and each section, (divided by ‘_’), is compared independently, and encrypted in a different way.
Future design aspects we plan to add to the C code over the two weeks include control flow flattening and opaque predicates to add more complexity for the reversers to parse through. Once the C is complete we will also be able to go into our assembly code and use bloated equivalents and control indirection to make Ghidra harder to use efficiently


Obfuscation Techniques: 
To obfuscate strings in our program, we have combined several of the approaches discussed in class. Firstly, we do not store any strings, besides trivial strings that are printed to the standard out together; all of the meaningful strings in our program are stored split up, so they are not easily detectable by using the strings function. We have also edited the assembly to hide strings using the stack.
When the program goes to check the entered password, we did not want to be comparing directly to the correct password, so we have each chunk be encrypted in a certain way and then checked against the encrypted version of the correct password. The techniques used for this encryption includes different combinations of XOR’ing and addition. Many of the sub-functions are also filled with garbage code sections, intended to distract the reversers and clutter Ghidra.


Solution Strategies:
        Our current code relies on many sub-functions which return an output of 0 or 1 based on whether the checked section of code was correct. One strategy other teams could use to trick our program into printing out the location would be to step through with gdb and use the set register values after each function returns. By manually setting the register value to 1 before it is checked for the if-statement comparisons, the reversing team could make the program falsely believe they had entered the correct password.


Individual Contributions:
* Audrey: wrote all of the C check… functions and framework in main to determine whether the complete, valid password was entered
* Aloye: added some string hiding techniques to the C code and and the assembly code to make it difficult to find important strings with the strings command line call.
* Jason: Wrote sed script to replace some assembly code with bloated equivalents automatically. Wrote Makefile pipeline to automatically assemble, apply bloated equivalents, compile, and strip executables.
